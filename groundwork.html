<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Can sparse Bayesian independent component analysis describe gene regulation?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="groundwork_files/libs/clipboard/clipboard.min.js"></script>
<script src="groundwork_files/libs/quarto-html/quarto.js"></script>
<script src="groundwork_files/libs/quarto-html/popper.min.js"></script>
<script src="groundwork_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="groundwork_files/libs/quarto-html/anchor.min.js"></script>
<link href="groundwork_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="groundwork_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="groundwork_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="groundwork_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="groundwork_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#imodulons" id="toc-imodulons" class="nav-link" data-scroll-target="#imodulons">Imodulons</a></li>
  <li><a href="#independent-component-analysis" id="toc-independent-component-analysis" class="nav-link" data-scroll-target="#independent-component-analysis">Independent Component Analysis</a></li>
  <li><a href="#transcriptomics-data" id="toc-transcriptomics-data" class="nav-link" data-scroll-target="#transcriptomics-data">Transcriptomics data</a></li>
  </ul></li>
  <li><a href="#our-project" id="toc-our-project" class="nav-link" data-scroll-target="#our-project">Our project</a>
  <ul class="collapse">
  <li><a href="#why-we-want-to-attempt-a-bayesian-imodulon-analysis" id="toc-why-we-want-to-attempt-a-bayesian-imodulon-analysis" class="nav-link" data-scroll-target="#why-we-want-to-attempt-a-bayesian-imodulon-analysis">Why we want to attempt a Bayesian Imodulon analysis</a></li>
  <li><a href="#what-we-would-like-to-achieve" id="toc-what-we-would-like-to-achieve" class="nav-link" data-scroll-target="#what-we-would-like-to-achieve">What we would like to achieve</a></li>
  <li><a href="#measures-of-success" id="toc-measures-of-success" class="nav-link" data-scroll-target="#measures-of-success">Measures of success</a></li>
  <li><a href="#model" id="toc-model" class="nav-link" data-scroll-target="#model">Model</a></li>
  <li><a href="#sec-first-approach" id="toc-sec-first-approach" class="nav-link" data-scroll-target="#sec-first-approach">First approach</a></li>
  <li><a href="#orthogonality" id="toc-orthogonality" class="nav-link" data-scroll-target="#orthogonality">Orthogonality</a></li>
  <li><a href="#design-matrices" id="toc-design-matrices" class="nav-link" data-scroll-target="#design-matrices">Design matrices</a></li>
  <li><a href="#about-the-global-scale" id="toc-about-the-global-scale" class="nav-link" data-scroll-target="#about-the-global-scale">About the global scale</a></li>
  <li><a href="#whitening" id="toc-whitening" class="nav-link" data-scroll-target="#whitening">Whitening</a></li>
  </ul></li>
  <li><a href="#where-we-need-help" id="toc-where-we-need-help" class="nav-link" data-scroll-target="#where-we-need-help">Where we need help</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="groundwork.docx"><i class="bi bi-file-word"></i>MS Word</a></li></ul></div></nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Can sparse Bayesian independent component analysis describe gene regulation?</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>We think we could use a sparse Bayesian independent component analysis model to describe gene regulation in <em>E. coli</em> and other organisms for which there is RNA sequencing data. This document explains why we think this, how we would like do it and where we need help.</p>
<section id="background" class="level1 page-columns page-full">
<h1>Background</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Living cells respond to environmental changes by up- or down-regulating their genes, thereby changing the proportion in which the cell produces proteins, which in turn alters the cell’s behaviour. For example, a cell that moves into a toxic environment might alter its gene expression so as to increase production of a protein that exports the toxin or to decrease toxin-importing proteins.</p>
<p>By analysing RNA transcripts it is possible to measure gene expression and see how it varies across conditions. There is now so much transcriptomics data available that it plauibly contains sufficient information to learn how some organisms orchestrate their gene regulation. <span class="citation" data-cites="tanIndependentComponentAnalysis2020">Tan et al. (<a href="#ref-tanIndependentComponentAnalysis2020" role="doc-biblioref">2020</a>)</span> achieved this goal using a method based on independent component analysis or ICA, leading to the development of the concept of an Imodulon.</p>
</section>
<section id="imodulons" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="imodulons">Imodulons</h2>
<p>An Imodulon is a hypothetical latent allocation of weights to a subset of genes derived from the results of an analysis involving ICA, that is taken to represent a way that a cell can regulate its genes in response to changing conditions. For example, suppose a certain Imodulon I1 regulates just two genes G1 and G2 with respective weights 0.5 and -0.5. When I1 is activated, G1 will be up-regulated and G2 will be down-regulated by the same amount. In contrast, when I1 is deactivated, the opposite regulation will occur. It is typically presumed that there are far fewer Imodulons than genes, that an Imodulon will substantially up- or down-regulate the genes that it affects, and that most Imodulons will affect a relatively small number of genes.</p>
<div class="page-columns page-full"><p>It is plausible that Imodulons roughly describe how gene regulation works because of the known existence of transcription units, transcription factors and regulons. Transcription units are sets of genes that share an RNA binding site and can therefore only be regulated together. Transcription factors are proteins that activate or deactivate particular transcription units. Regulons are sets of genes that are regulated by exactl the same transcription factors. Since there are known to be many of all these things, it is likely that a latent representation like Imodulons is roughly correct. In particular, based on the <a href="https://regulondb.ccg.unam.mx/index.jsp">regulonDB</a> it is clear that most transcription factors affect a small number of genes and that there are fewer transcription factors than genes.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;Note that Imodulons are not the same as transcription factors!</p></li></div></div>
<p>Whereas previous analyses have attempted to fit ICA models using an approach based on optimisation, we would like to fit a Bayesian statistical model that implements ICA. We would like our statistical model to include an explicit representation of the assumptions about Imodulon sparsity outlined above.</p>
</section>
<section id="independent-component-analysis" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="independent-component-analysis">Independent Component Analysis</h2>
<div class="page-columns page-full"><p>Independent component analysis assumes that the numbers comprising an <span class="math inline">\(I\times J\)</span> matrix of observations <span class="math inline">\(X\)</span> are generated by taking weighted sums of a known number <span class="math inline">\(K &lt; J\)</span> independent component vectors, as shown below: <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;Term names chosen for consistency with the Imodulon papers</p></li></div></div>
<p><span id="eq-ica-long"><span class="math display">\[
\begin{equation}
  x_{ij}=\sum_{k=1}^{K} m_{ik}a_{kj}
\end{equation}
\tag{1}\]</span></span></p>
<p>or in matrix notation</p>
<p><span id="eq-ica"><span class="math display">\[
\begin{equation}
X = MA
\end{equation}
\tag{2}\]</span></span></p>
<p>It is assumed that the columns of the matrix <span class="math inline">\(A\)</span> are column-wise probabilistically independent, so that the probability of the <span class="math inline">\(j\)</span>th column of <span class="math inline">\(A\)</span> is the product of the <span class="math inline">\(K\)</span> marginal probabilities, i.e.&nbsp;<span class="math inline">\(p(a_{:j}) = \prod_{k=1}^I p(a_{kj})\)</span>. Secondly, it is also assumed that the rows of <span class="math inline">\(A\)</span> have non-Gaussian marginal distributions. See <span class="citation" data-cites="hyvarinenIndependentComponentAnalysis2000">Hyvärinen and Oja (<a href="#ref-hyvarinenIndependentComponentAnalysis2000" role="doc-biblioref">2000</a>)</span> for a discussion of an optimisation based approach to Independent component analysis and <span class="citation" data-cites="robertsBayesianIndependentComponent2005">Roberts and Choudrey (<a href="#ref-robertsBayesianIndependentComponent2005" role="doc-biblioref">2005</a>)</span> for a discussion of Bayesian independent component analysis.</p>
<p>In the canonical application of ICA each row of <span class="math inline">\(X\)</span> represents a time course of signals from a receiver detecting input from <span class="math inline">\(k\)</span> sources; each row of <span class="math inline">\(A\)</span> represents the time course of signals from a source; each column of <span class="math inline">\(M\)</span> represents how a source mixes between receivers. In the context of a transcriptomics data analysis the observation units are genes rather than receivers, the observation rows represent separate experiments rather than time courses and the columns of the matrix <span class="math inline">\(M\)</span> represents proto-Imodulons, i.e. mixing weights for each gene for each proto-Imodulon. A separate downstream analysis is required in order to sparsify the results by removing genes from Imodulons and discarding some candidate Imodulons.</p>
<p>The Python library Scikit learn provides access to <a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html">an implementation of ICA</a> based on minimsation of mutual information, as outlined in <span class="citation" data-cites="hyvarinenIndependentComponentAnalysis2000">Hyvärinen and Oja (<a href="#ref-hyvarinenIndependentComponentAnalysis2000" role="doc-biblioref">2000</a>)</span>.</p>
</section>
<section id="transcriptomics-data" class="level2">
<h2 class="anchored" data-anchor-id="transcriptomics-data">Transcriptomics data</h2>
<p>The <a href="https://github.com/SBRG/precise-db">precise-db</a> provides a large collection of RNA sequencing data that can be used to create suitable input for independent component analysis.</p>
<p>Like with other RNA sequencing data, each gene expression measurement in precise-db starts as a count of the number of times an mRNA fragment that maps to the gene was detected in the experiment fragments per transcript. Unfortunately such counts are not comparable between genes within a sample because they are sensitive to the size of the mRNA fragment that encodes the gene (a big gene will tend to be counted more often than an equally expressed small gene). Raw counts are also not comparable between samples because of potential variations in sequence depth (i.e.&nbsp;the total number of measurements from the sample) and the mRNA-fragment-to-gene map used. Consequently the usual practice is to transform raw counts by first normalising based on the gene size and then ‘proportionising’, ending with a relative unit called transcripts per million or TPM:</p>
<p><span id="eq-tpm"><span class="math display">\[
\begin{equation}
TPM(g) = \frac{count(g)/size(g)}{\sum_{i\in sample}count(i)/size(i)}
\end{equation}
\tag{3}\]</span></span></p>
<p>See <span class="citation" data-cites="zhaoMisuseRPKMTPM2020">Zhao, Ye, and Stanton (<a href="#ref-zhaoMisuseRPKMTPM2020" role="doc-biblioref">2020</a>)</span> for discussion of the transcripts per million normalisation and for references to more papers about RNA sequencing experiments.</p>
<p>For use in imodulon analysis further transformations are performed. First the transcripts per million are put on log scale, then the log-transcripts per million of a reference condition are subtracted. Finally the data are whitened using scikit-learn’s <code>arbitrary-variance</code> option.</p>
</section>
</section>
<section id="our-project" class="level1">
<h1>Our project</h1>
<section id="why-we-want-to-attempt-a-bayesian-imodulon-analysis" class="level2">
<h2 class="anchored" data-anchor-id="why-we-want-to-attempt-a-bayesian-imodulon-analysis">Why we want to attempt a Bayesian Imodulon analysis</h2>
<p>There are several general reasons to prefer Bayesian ICA models to models that use a maximum likelihood approach, including automatic relevance detection, the potential to take into account quantitative non-measurement information through a prior model, and the avoidance of pathological model behaviour due to bad or incomplete observations. These general reasons are discussed in <span class="citation" data-cites="robertsBayesianIndependentComponent2005">Roberts and Choudrey (<a href="#ref-robertsBayesianIndependentComponent2005" role="doc-biblioref">2005</a>)</span>.</p>
<p>These advantages are particularly pertinent for the application of ICA to attempting to infer Imodulons from RNA sequencing data.</p>
<p>First, as described in <span class="citation" data-cites="robertsBayesianIndependentComponent2005">Roberts and Choudrey (<a href="#ref-robertsBayesianIndependentComponent2005" role="doc-biblioref">2005</a>)</span>, a Bayesian ICA model can potentially use automatic relevance detection to find an appropriate number of Imodulons to postulate. Whereas in the current framework the appropriate number of Imodulons is determined using a procedure that is separate from the main inference and motivated by computational and algorithmic considerations—primarily whether the algorithm successfully converges—rather than substantive statistical ones, relevance detection based on hyperparameters in the context of a Bayesian model is well-motivated and does not require downstream processing.</p>
<p>Second, there is substantial non-experimental information about Imodulons that should provide important context to RNA sequencing measurements. In particular, as discussed above investigation of regulons and transcription factors suggests that an Imodulon should typically affect a relatively small number of genes. Maximum-likelihood based Imodulon analysis uses another non-statistically-motivated downstream procedure to impose this sparsity after fitting an ICA model. We would like to represent this information in a Bayesian ICA model by using a sparsity-inducing prior for the columns of the mixing matrix <span class="math inline">\(M\)</span>.</p>
<p>Another potential source of non-experimental information is the research into regulons and transcription factors itself. Many genes, particularly those in a species’s ‘core’ genome that are common to almost all strains, are known in advance to share specific regulators, and this information can be taken into account in a Bayesian framework through informative priors on specific elements of the mixing matrix <span class="math inline">\(M\)</span>.</p>
<p>Finally, the robustness gained by using a Bayesian statistical analysis is likely to be helpful when attempting to infer Imodulons for species with fewer RNA sequencing experiments.</p>
</section>
<section id="what-we-would-like-to-achieve" class="level2">
<h2 class="anchored" data-anchor-id="what-we-would-like-to-achieve">What we would like to achieve</h2>
<p>Ultimately we would like to create a sparse Bayesian ICA model that can reproduce the analysis in <span class="citation" data-cites="tanIndependentComponentAnalysis2020">Tan et al. (<a href="#ref-tanIndependentComponentAnalysis2020" role="doc-biblioref">2020</a>)</span> of the precise-db dataset. This analysis inferred 92 Imodulons from RNA sequencing measurements of 4386 genes in 278 conditions. We would then like to use the same approach to analyse RNA sequencing data from organisms with fewer measurements and to augment our model with informative priors based on information about regulons.</p>
<p>As a proof of concept we would like to generate and then fit a smaller artificial dataset with uninformative but still sparsity-inducing priors, then fit the same model to a subset of the precise-db dataset.</p>
</section>
<section id="measures-of-success" class="level2">
<h2 class="anchored" data-anchor-id="measures-of-success">Measures of success</h2>
<p>We can consider an ICA successful if it provides <em>robust</em> imodulons. These robustness can be measured in two ways: experimental saturation and internal replicability.</p>
<p><em>Experimental saturation</em> is achieved when the imodulons remain stable upon adding more experiments. We can simulate this by random ablation of the experimental conditions before performing ICA.</p>
<p>We should see first that the number of imodulons remains the same and, second, that the number of genes in each imodulon remains more or less the same (parameters in <span class="math inline">\(M\)</span>). Both can be visualized with a sankey plot.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ggplot2, ggsankey, ggalluvial and dplyr must be installed</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggsankey)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We have run ICA for 25 to 39 random conditions on a private dataset and gathered the <span class="math inline">\(M\)</span> matrices on a single dataset.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># data has been anonymized since it is part of a private dataset</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/out_sankey_anon.tsv"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># fix the modulon_this column for the last stage</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>df[df<span class="sc">$</span>stage <span class="sc">==</span> <span class="st">"39_10"</span>, <span class="st">"modulon_this"</span>] <span class="ot">&lt;-</span> df[df<span class="sc">$</span>stage <span class="sc">==</span> <span class="st">"39_10"</span>, <span class="st">"modulon"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#fig-sankey-gene">Figure&nbsp;1</a> shows that the number of imodulons is not stable across ablation runs (see the jump from 29 to 30). The composition of each imodulon does not seem to be very stable. Additionally, this plot hightlights the high number of genes that are not assigned to any imodulon.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(<span class="at">x =</span> stage, <span class="at">next_x =</span> <span class="fu">factor</span>(next_stage),</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">node =</span> <span class="fu">factor</span>(modulon_this),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">next_node =</span> <span class="fu">factor</span>(modulon_next),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">fill =</span> <span class="fu">factor</span>(modulon_this), <span class="at">label =</span> modulon_this)) <span class="sc">+</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>       <span class="fu">geom_alluvial</span>(<span class="at">flow.alpha =</span> .<span class="dv">4</span>, <span class="at">node.alpha =</span> .<span class="dv">7</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>          <span class="at">width =</span> .<span class="dv">25</span>, <span class="at">node.color =</span> <span class="st">"gray70"</span>) <span class="sc">+</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>       <span class="fu">geom_alluvial_text</span>(<span class="at">size =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">"gray20"</span>) <span class="sc">+</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>       <span class="fu">scale_fill_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>       <span class="fu">theme_alluvial</span>(<span class="at">base_size =</span> <span class="dv">16</span>) <span class="sc">+</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>       <span class="fu">labs</span>(<span class="at">x =</span> <span class="cn">NULL</span>) <span class="sc">+</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>       <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>, <span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">90</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-sankey-gene" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="groundwork_files/figure-html/fig-sankey-gene-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Gene belonging to imodulons across ablation runs.</figcaption>
</figure>
</div>
</div>
</div>
<p>There are some artifacts were some of the genes appear to flow into nothing (see imodulon 0 at the bottom). This should not be possible since all genes get assigned to a node (modulon) on every stage (condition run). The issue is that genes can be part of more than one imodulon and that results in “duplicated” strands of flow (alluvium) disappearing.</p>
<p>In the same line of “experimentally saturated”, we can check whether an imodulon has stable activity for the different conditions across ablation runs (parameters in <span class="math inline">\(A\)</span>).</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggalluvial)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>From the aforementioned ICA runs, the <span class="math inline">\(A\)</span> matrices were also gathered.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df_cond <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/out_sankey_cond_anon.tsv"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\t</span><span class="st">"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_cond)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  X modulon condition     weight stage next_stage
1 0       0        S0 -0.8864822 26_10         NA
2 1       1        S0  1.3514882 26_10         NA
3 2       2        S0  1.7112368 26_10         NA
4 3       3        S0  2.3598187 26_10         NA
5 4       4        S0  5.3243216 26_10         NA
6 5       5        S0 -0.3278940 26_10         NA</code></pre>
</div>
</div>
<p>Let’s prepare the data a bit:</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>df_cond_abs <span class="ot">&lt;-</span> df_cond</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df_cond_abs<span class="sc">$</span>weight <span class="ot">&lt;-</span> <span class="fu">abs</span>(df_cond_abs<span class="sc">$</span>weight)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>df_cond_abs<span class="sc">$</span>modulon_condition <span class="ot">&lt;-</span> <span class="fu">paste</span>(df_cond_abs<span class="sc">$</span>modulon,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                                      df_cond_abs<span class="sc">$</span>condition, <span class="at">sep =</span> <span class="st">"_"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>complete <span class="ot">&lt;-</span> tidyr<span class="sc">::</span><span class="fu">complete</span>(df_cond_abs, modulon_condition,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                            stage, <span class="at">fill =</span> <span class="fu">list</span>(<span class="at">weight =</span> <span class="dv">0</span>))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>complete[<span class="fu">is.na</span>(complete<span class="sc">$</span>modulon), <span class="st">"modulon"</span>] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(stringr<span class="sc">::</span><span class="fu">str_split_fixed</span>(complete[<span class="fu">is.na</span>(complete<span class="sc">$</span>modulon), ]<span class="sc">$</span>modulon_condition, <span class="st">"_"</span>, <span class="dv">2</span>)[, <span class="dv">1</span>])</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>complete[<span class="fu">is.na</span>(complete<span class="sc">$</span>condition), <span class="st">"condition"</span>] <span class="ot">&lt;-</span> stringr<span class="sc">::</span><span class="fu">str_split_fixed</span>(complete[<span class="fu">is.na</span>(complete<span class="sc">$</span>condition), ]<span class="sc">$</span>modulon_condition, <span class="st">"_"</span>, <span class="dv">2</span>)[, <span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Color based on experimental conditions (“condition” is the biological replicate in the dataframe):</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>complete_exp <span class="ot">&lt;-</span> complete <span class="sc">%&gt;%</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">experiment =</span> <span class="fu">case_when</span>(stringr<span class="sc">::</span><span class="fu">str_starts</span>(condition, <span class="st">"local"</span>) <span class="sc">~</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                                stringr<span class="sc">::</span><span class="fu">str_extract</span>(condition, <span class="st">"local_([0-9]{3})[a-z]?_"</span>, <span class="at">group =</span> <span class="dv">1</span>),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                              <span class="sc">!</span>stringr<span class="sc">::</span><span class="fu">str_starts</span>(condition, <span class="st">"local"</span>) <span class="sc">~</span> <span class="st">"S"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a href="#fig-sankey-condition">Figure&nbsp;2</a> shows the same problem as before but now for the conditions. In general, the weights of the imodulons over the conditions are not very stable across runs.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(complete_exp,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">x =</span> stage, <span class="at">stratum =</span> <span class="fu">factor</span>(condition),</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">alluvium =</span> modulon_condition, <span class="at">y =</span> weight, <span class="at">label =</span> condition)) <span class="sc">+</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_stratum</span>(<span class="fu">aes</span>(<span class="at">color =</span> <span class="fu">factor</span>(experiment))) <span class="sc">+</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_alluvium</span>(<span class="fu">aes</span>(<span class="at">fill =</span> <span class="fu">factor</span>(modulon))) <span class="sc">+</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_text</span>(<span class="at">stat =</span> <span class="st">"stratum"</span>, <span class="at">size =</span> <span class="dv">2</span>, <span class="at">color =</span> <span class="st">"gray30"</span>) <span class="sc">+</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_fill_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">text =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="dv">16</span>)) <span class="sc">+</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">#theme(legend.position = NaN) +</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Condition run"</span>) <span class="sc">+</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Condition weight"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-sankey-condition" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="groundwork_files/figure-html/fig-sankey-condition-1.png" class="img-fluid figure-img" width="4800"></p>
<figcaption class="figure-caption">Figure&nbsp;2: iModulon weights of conditions across ablation runs.</figcaption>
</figure>
</div>
</div>
</div>
<p>Finally, for the <em>replicability measure</em> we can check whether the conditions display the same imodulon profile across biological replicates for the whole (non-ablated) dataset.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df_cond_39loc <span class="ot">&lt;-</span> df_cond <span class="sc">%&gt;%</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(stage <span class="sc">==</span> <span class="st">"39_10"</span>, stringr<span class="sc">::</span><span class="fu">str_starts</span>(condition, <span class="st">"local"</span>)) <span class="sc">%&gt;%</span>  <span class="co"># only the local ones are actual bio replicates</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">experiment =</span> stringr<span class="sc">::</span><span class="fu">str_extract</span>(condition, <span class="st">"local_([0-9]{3})[a-z]?_"</span>, <span class="at">group =</span> <span class="dv">1</span>))  <span class="sc">%&gt;%</span> <span class="co"># extract the experiment (OOX)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="st">`</span><span class="at">biological replicate</span><span class="st">`</span> <span class="ot">=</span> stringr<span class="sc">::</span><span class="fu">str_extract</span>(condition, <span class="st">"[A-Z]$"</span>)) <span class="co"># extract the biological replicate (A,B,C)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_cond_39loc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>   X modulon   condition      weight stage next_stage experiment
1 28       0 local_031_A  -5.1886962 39_10         NA        031
2 29       1 local_031_A  -0.8093426 39_10         NA        031
3 30       2 local_031_A  -8.3916830 39_10         NA        031
4 31       3 local_031_A   1.3236297 39_10         NA        031
5 32       4 local_031_A  -3.0924300 39_10         NA        031
6 33       5 local_031_A -16.3806644 39_10         NA        031
  biological replicate
1                    A
2                    A
3                    A
4                    A
5                    A
6                    A</code></pre>
</div>
</div>
<p>In this case, in <a href="#fig-repl-profile">Figure&nbsp;3</a> the experimental condition 005 does not show good replicability.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df_cond_39loc, <span class="fu">aes</span>(<span class="at">x =</span> modulon, <span class="at">color =</span> <span class="fu">factor</span>(<span class="st">`</span><span class="at">biological replicate</span><span class="st">`</span>),</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">y =</span> weight)) <span class="sc">+</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="st">"~experiment"</span>, <span class="at">scales =</span> <span class="st">"free"</span>) <span class="sc">+</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">text =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="fl">22.0</span>)) <span class="sc">+</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">color =</span> <span class="st">"Biological replicate"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-repl-profile" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="groundwork_files/figure-html/fig-repl-profile-1.png" class="img-fluid figure-img" width="2880"></p>
<figcaption class="figure-caption">Figure&nbsp;3: iModulon condition weights across replicates for the whole dataset.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="model" class="level2">
<h2 class="anchored" data-anchor-id="model">Model</h2>
<p>In contrast to the model in <span class="citation" data-cites="hyvarinenIndependentComponentAnalysis2000">Hyvärinen and Oja (<a href="#ref-hyvarinenIndependentComponentAnalysis2000" role="doc-biblioref">2000</a>)</span> and previous Imodulon analyses we propose to include measurement noise in our statistical model. Although it would perhaps be preferable to model the whole data generation process up to the production of untransformed raw counts, for the sake of simplicity and easier comparison with previous approaches we will use the following simple linear regression model for transformed RNA sequencing data, assuming known measurement error <span class="math inline">\(\sigma\)</span>:</p>
<p><span id="eq-noise-likelihood"><span class="math display">\[
\begin{equation*}
y \sim N(\hat{y}, \sigma)
\end{equation*}
\tag{4}\]</span></span></p>
<p>In order to ensure that our model implements ICA we will use a column-wise independent and row-wise non-Gaussian prior distribution for the source strength matrix <span class="math inline">\(A\)</span>:</p>
<p><span id="eq-source-model"><span class="math display">\[
\begin{equation*}
a_kj \sim T4(0,1)
\end{equation*}
\tag{5}\]</span></span></p>
<p>In <a href="#eq-source-model">Equation&nbsp;5</a> <span class="math inline">\(T4\)</span> refers to the student-t distribution with 4 degrees of freedom. The use of a unit scale for each row is beause ICA models are identified only up to a change of scale</p>
<p>We will use independent regularised horseshoe priors for the columns of the mixing matrix <span class="math inline">\(M\)</span>:</p>
<p><span id="eq-mixing-model"><span class="math display">\[
\begin{align*}
m_{ik} &amp;\sim N^+(0, \tau_k\tilde{\lambda}_{ik}) \\
\tilde{\lambda}_{ik})^2 &amp;= \frac{c_k^2\lambda_{ik}^2}{c_k^2 + \tau_k^2\lambda_{ik}^2} \\
\lambda_{ik} &amp;\sim C^+(0, 1) \\
c_k^2 &amp;\sim \text{inverse gamma}(\alpha, \beta) \\
\tau_k &amp;\sim C^+(0, \tau_{k0})
\end{align*}
\tag{6}\]</span></span></p>
<p>In <a href="#eq-mixing-model">Equation&nbsp;6</a> <span class="math inline">\(C^+\)</span> and <span class="math inline">\(N^+\)</span> refer respectively to Cauchy and Normal distributions with support only on the positive real line, and the terms <span class="math inline">\(alpha\)</span>, <span class="math inline">\(\beta\)</span> and <span class="math inline">\(tau_{k0}\)</span> are informative priors. Note that the mixing matrix prior is constrained to have support only on the non-negative real line. This is done, following <span class="citation" data-cites="robertsBayesianIndependentComponent2005">Roberts and Choudrey (<a href="#ref-robertsBayesianIndependentComponent2005" role="doc-biblioref">2005</a>)</span>, to ensure sign consistency, so that a positive relative change in an Imodulon’s strength in a certain condition will always correspond to up-regulation of genes affected by that Imodulon.</p>
</section>
<section id="sec-first-approach" class="level2">
<h2 class="anchored" data-anchor-id="sec-first-approach">First approach</h2>
<p>We merely expressed <a href="#eq-mixing-model">Equation&nbsp;6</a> in stan this with two matrices <span class="math inline">\(M\)</span> and <span class="math inline">\(A\)</span> instead of one (mimicking the ICA representation) that, when multiplied, give rise to <span class="math inline">\(\hat y\)</span>.</p>
<p>This worked for simulated data to some extent. For real data, using the <a href="https://github.com/SBRG/precise-db">precise-db</a>, we faced the following issues:</p>
<ol type="1">
<li>The max tree depth had to be set to 1 to get any sampling. This is a problem since that the MCMC chains take too long to sample to do any real inference.</li>
<li>The output is too big. In the end we end with a 30GB file per chain (given the huge amount of columns in the output). This is very difficult to handle.</li>
</ol>
<p>The results retain some sparsity. These are some of the traces of some arbitrarily picked parameters of <span class="math inline">\(M\)</span>:</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/lambda4.1start.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(lambda_tilde_mode.<span class="fl">4.1</span><span class="sc">:</span>lambda_tilde_mode.<span class="fl">4.19</span>, <span class="at">names_to =</span> <span class="st">"params"</span>, <span class="at">values_to =</span> <span class="st">"value"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> value, <span class="at">fill =</span> params)) <span class="sc">+</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>(<span class="at">alpha=</span><span class="fl">0.3</span>, <span class="at">color=</span><span class="st">"gray"</span>) <span class="sc">+</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">text =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="fl">18.0</span>), <span class="at">legend.position =</span> <span class="fu">c</span>(.<span class="dv">9</span>, .<span class="dv">9</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="groundwork_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The same for variational inference (took less than an hour):</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"data/lambda4.1_variational.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>df <span class="sc">%&gt;%</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(lambda_tilde_mode.<span class="fl">4.1</span><span class="sc">:</span>lambda_tilde_mode.<span class="fl">4.19</span>, <span class="at">names_to =</span> <span class="st">"params"</span>, <span class="at">values_to =</span> <span class="st">"value"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> value, <span class="at">fill =</span> params)) <span class="sc">+</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_density</span>(<span class="at">alpha=</span><span class="fl">0.3</span>, <span class="at">color=</span><span class="st">"gray"</span>) <span class="sc">+</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">text =</span> <span class="fu">element_text</span>(<span class="at">size =</span> <span class="fl">18.0</span>), <span class="at">legend.position =</span> <span class="fu">c</span>(.<span class="dv">9</span>, .<span class="dv">9</span>)) <span class="sc">+</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">trans=</span><span class="st">'log10'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="groundwork_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Using partial pooling with shared parameters over the <span class="math inline">\(A\)</span> matrix helped to achieve a better sampling, but still hitting the max tree depth set at 10 at every draw.</p>
</section>
<section id="orthogonality" class="level2">
<h2 class="anchored" data-anchor-id="orthogonality">Orthogonality</h2>
<p>From the previous analysis, we can see that <span class="math inline">\(M\)</span> and <span class="math inline">\(A\)</span> matrices should be further constrained. The charasteristic constrain of ICA is the orthogonality; such that result is that of <em>Independent Components</em>.</p>
<p><span class="citation" data-cites="jauchMonteCarloSimulation2019">Jauch, Hoff, and Dunson (<a href="#ref-jauchMonteCarloSimulation2019" role="doc-biblioref">2019</a>)</span> proposes a polar expansion (<a href="#eq-polar">Equation&nbsp;7</a>) to achieve this. The authors proposed a PCA generative model using this expansion that we can adapt for our needs in <a href="#eq-or-pca">Equation&nbsp;8</a>.</p>
<p><span id="eq-polar"><span class="math display">\[
\begin{align}
\lambda(X) &amp;= \texttt{eigenvalues}(X X^T) \\
X^p_{m} &amp;= \frac{1}{\sqrt{\lambda(X)_m}}
\end{align}
\tag{7}\]</span></span></p>
<p><span id="eq-or-pca"><span class="math display">\[
\begin{align}
  M_{m,g} &amp;\sim N(0, \sigma) \\
  M^\ast &amp;= M \xi(M) diag(M^p) \xi(M)  \\
  A_{m,g} &amp;\sim N(0, \sigma) \\
  A^\ast &amp;= A \xi(A) diag(A^p) \xi(A)  \\
  \nu &amp;\sim \text{inverse gamma} \\
  D &amp;\sim N(0, \tau) \\
  y &amp;\sim N(M^\ast diag(D) A^\ast, \nu)
\end{align}
\tag{8}\]</span></span></p>
<p>where <span class="math inline">\(\xi\)</span> is defined as <a href="#eq-xi">Equation&nbsp;9</a>. This of course did not produce sparse results (<a href="#fig-or-pca">Figure&nbsp;4</a>).</p>
<p><span id="eq-xi"><span class="math display">\[
\xi(X) = \texttt{eigenvectors}(X X^T)   
\tag{9}\]</span></span></p>
<div id="fig-or-pca" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="data/or_pca.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Three first latent modulon vectors of <span class="math inline">\(M\)</span> for each gene across <em>Escherichia coli</em> genome yielded by orthogonal PCA</figcaption>
</figure>
</div>
<p>We can reintroduce the regularized horseshoe, this time only for the M priors after the orthogonality (<span class="math inline">\(M_p\)</span>) and changing the prior of <span class="math inline">\(M\)</span> to a t-student as in <a href="#eq-source-model">Equation&nbsp;5</a>. The 90 inferred modulons (chosen as the number identified by classical ICA) for <em>Escherichia coli</em> are shown in <a href="#fig-or-ica-90">Figure&nbsp;5</a>, where sparsity can be seen for the different latent modulons.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> arviz <span class="im">as</span> az</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># not included in the repo since it is 4 GB</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>idata <span class="op">=</span> az.from_cmdstan([<span class="st">"../spbica/res/sparse_orthogonal_nov-20230915233645_1.csv"</span>])</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>all_us <span class="op">=</span> []</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>dfs <span class="op">=</span> []</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">90</span>):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> idata.posterior.U_tilde.sel({<span class="st">"chain"</span>: <span class="dv">0</span>, <span class="st">"U_tilde_dim_1"</span>: i}).to_pandas()</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    u[<span class="st">"modulon"</span>] <span class="op">=</span> i</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    dfs.append(u)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        all_us.append(</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            pd.melt(pd.concat(dfs), id_vars<span class="op">=</span><span class="st">"modulon"</span>, var_name<span class="op">=</span><span class="st">"gene"</span>)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>            .groupby([<span class="st">"modulon"</span>, <span class="st">"gene"</span>])</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>            .agg(</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>                down<span class="op">=</span>pd.NamedAgg(<span class="st">"value"</span>, <span class="kw">lambda</span> x: np.percentile(x, <span class="dv">25</span>)),</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>                up<span class="op">=</span>pd.NamedAgg(<span class="st">"value"</span>, <span class="kw">lambda</span> x: np.percentile(x, <span class="dv">95</span>)),</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>                median<span class="op">=</span>pd.NamedAgg(<span class="st">"value"</span>, <span class="kw">lambda</span> x: np.percentile(x, <span class="dv">50</span>)),</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>                uran<span class="op">=</span>pd.NamedAgg(</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"value"</span>, <span class="kw">lambda</span> x: np.percentile(x, <span class="dv">95</span>) <span class="op">-</span> np.percentile(x, <span class="dv">25</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>                ),</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            .reset_index()</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> dfs</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        dfs <span class="op">=</span> []</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>all_us <span class="op">=</span> pd.concat(all_us)</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>all_us.to_csv(<span class="st">"data/all_us_or.tsv"</span>, index<span class="op">=</span><span class="va">False</span>, sep<span class="op">=</span><span class="st">"</span><span class="ch">\t</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotnine <span class="im">as</span> p9</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>all_us: pd.DataFrame <span class="op">=</span> pd.read_csv(<span class="st">"data/all_us_or.tsv"</span>, sep<span class="op">=</span><span class="st">"</span><span class="ch">\t</span><span class="st">"</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>(</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    p9.ggplot(</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        all_us.reset_index(),</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># it would be better to use tau as the color to indicate membership</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        p9.aes(ymin<span class="op">=</span><span class="st">"down"</span>, ymax<span class="op">=</span><span class="st">"up"</span>, y<span class="op">=</span><span class="st">"median"</span>, x<span class="op">=</span><span class="st">"gene"</span>, color<span class="op">=</span><span class="st">"uran"</span>),</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> p9.geom_errorbar()</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> p9.geom_point()</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> p9.facet_wrap(<span class="st">"~modulon"</span>, scales<span class="op">=</span><span class="st">"free_y"</span>, <span class="bu">dir</span><span class="op">=</span><span class="st">"v"</span>, ncol<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span> p9.theme(figure_size<span class="op">=</span>(<span class="dv">20</span>, <span class="dv">40</span>))</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Figure Size: (2000 x 4000)&gt;</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-or-ica-90" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="groundwork_files/figure-html/fig-or-ica-90-1.png" class="img-fluid figure-img" width="1920"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Orthogonal, sparse modulon vectors across <em>Escherichia coli</em> genome</figcaption>
</figure>
</div>
</div>
</div>
<p>However, altough faster to sample, the chains are still hitting the max tree depth. In the case of orthogonality, the <span class="math inline">\(M\)</span> matrix is not identifiable since there is a rotational invariance in the polar expansion. This is a problem for reporting such modulons. Another issue that becomes evident when looking at <a href="#fig-or-ica-90">Figure&nbsp;5</a> is that the positive-constraint on <span class="math inline">\(M\)</span> makes the modulons interpretation less straightforward in a biological sense, where we expect that a regulatory mode may increase the expression of some genes and decrease the expression of some other genes.</p>
<p>As aforementioned, <span class="citation" data-cites="robertsBayesianIndependentComponent2005">Roberts and Choudrey (<a href="#ref-robertsBayesianIndependentComponent2005" role="doc-biblioref">2005</a>)</span> showed the benefit of a positive constraint for Bayesian ICA with their mixture of gaussians model. However, they propposed the constrain for <span class="math inline">\(A\)</span> — leaving <span class="math inline">\(M\)</span> unconstrained —, the opposite of what we are doing. Would it be sound to remove the squared term of <span class="math inline">\(\lambda\)</span> in the definition of <span class="math inline">\(\tilde{\lambda}\)</span> (<a href="#eq-mixing-model">Equation&nbsp;6</a>) to support <span class="math inline">\(M \in \mathbb{R}\)</span>?</p>
</section>
<section id="design-matrices" class="level2">
<h2 class="anchored" data-anchor-id="design-matrices">Design matrices</h2>
<p>The <a href="#sec-first-approach">Section&nbsp;2.5</a> was refined through the above discussion and compared with biological regulon data.</p>
<p>The first simple change was to make <span class="math inline">\(M\)</span> negative instead of <span class="math inline">\(A\)</span> and remove the sparsity from <span class="math inline">\(A\)</span>. Now, <a href="#eq-or-pca">Equation&nbsp;8</a> becomes</p>
<p><span id="eq-posA-rM"><span class="math display">\[
\begin{align}
\sigma_A &amp;\sim \text{inverse gamma} \\
A &amp;\sim N(0, \sigma_A) \\
z &amp;\sim N(0, 1) \in \mathbb{R}^{N_O, N_M} \\
\beta &amp;= z * \text{sparse}(M^\ast, \tau, c) \\
\hat y &amp;= \beta diag(D) A \\
y &amp;\sim N(\hat y, \nu)
\end{align}
\tag{10}\]</span></span></p>
<p>where <span class="math inline">\(N_M\)</span> is the number of modulons and <span class="math inline">\(N_O\)</span> is the number of operons. The latter is the second modification to the model.</p>
<p>Before, <span class="math inline">\(M\)</span> was generated as a linear application from Modulons to Genes. However, this is wasteful since genes are usually expressed in an operon in prokaryotes: adjacent genes in the genome are transcribed into a single mRNA that then in translated to the corresponding different proteins. We have this information available with some degree of evidence in databases like BioCyc, especially for organisms like <em>Escherichia coli</em>. Thus, <span class="math inline">\(M\)</span> is now an application from Modulons to Operons. With a <em>gene to operon</em> link array <code>GxO</code>, <span class="math inline">\(\hat y\)</span> is then expanded to the genes in the measurement model</p>
<p><span class="math display">\[
y \sim N(\hat y[GxO, :], \nu)
\]</span></p>
<p>The third modification applies this concept to <span class="math inline">\(A\)</span>. In this case, the source of the reduction of dimensions is the replicates. The data contains different replicate <em>runs</em> that correspond to the same <em>condition</em>. Hence, we can generate <span class="math inline">\(A \in \mathbb{R}^{m, c}\)</span>, where <span class="math inline">\(c\)</span> is the number of conditions and then expand it in the measurement model with a <em>run to condition</em> <code>RxC</code> link array:</p>
<p><span class="math display">\[
y \sim N(\hat y[GxO, RxC], \nu)
\]</span></p>
<p><span class="math inline">\(\nu\)</span> was set to the 75 percentile of the standard deviation of genes between replicates, trying to account for of the within-operon variance (the position in the operon affects the transcription and the translation levels <span class="citation" data-cites="limFundamentalRelationshipOperon2011b">Lim, Lee, and Hussein (<a href="#ref-limFundamentalRelationshipOperon2011b" role="doc-biblioref">2011</a>)</span>).</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.typing <span class="im">import</span> NDArray</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quantiles(x: NDArray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">float</span>, <span class="bu">float</span>, <span class="bu">float</span>]:</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.quantile(x, [<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>log_tpm <span class="op">=</span> pd.read_csv(<span class="st">"https://github.com/SBRG/precise-db/raw/master/data/log_tpm_norm.csv"</span>, index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>tidy_tpm <span class="op">=</span> pd.melt(</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    log_tpm.reset_index().rename(columns<span class="op">=</span>{<span class="st">"index"</span>: <span class="st">"gene"</span>}),</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    var_name<span class="op">=</span><span class="st">"run"</span>,</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    value_name<span class="op">=</span><span class="st">"logTPM"</span>,</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    id_vars<span class="op">=</span><span class="st">"gene"</span>,</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co"># if two runs are the same in all but the last character (replicate), they are</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="co"># the same condition, used for groupby and then compute stastics</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>tidy_tpm[<span class="st">"condition"</span>] <span class="op">=</span> tidy_tpm.run.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>tidy_tpm <span class="op">=</span> tidy_tpm.groupby([<span class="st">"condition"</span>, <span class="st">"gene"</span>]).agg(</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    mean<span class="op">=</span>pd.NamedAgg(<span class="st">"logTPM"</span>, np.mean),</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    std<span class="op">=</span>pd.NamedAgg(<span class="st">"logTPM"</span>, <span class="kw">lambda</span> x: np.std(x) <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>),</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>std <span class="op">=</span> tidy_tpm.loc[tidy_tpm[<span class="st">"std"</span>] <span class="op">!=</span> <span class="dv">0</span>, <span class="st">"std"</span>].to_numpy()</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>quantiles(std)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>array([0.03172568, 0.0752783 , 0.16098884])</code></pre>
</div>
</div>
<p>Apart from the above, the orthogonality constraint was applied to <span class="math inline">\(A\)</span> instead of <span class="math inline">\(M\)</span> (now correctly adhering to the original ICA concept).</p>
<p>Furthermore, the results of running this prototype were computed using the same protocol as in <span class="citation" data-cites="sastryEscherichiaColiTranscriptome2019a">Sastry et al. (<a href="#ref-sastryEscherichiaColiTranscriptome2019a" role="doc-biblioref">2019</a>)</span>, where the F1-score is computed between the modulons and the reference regulons as a measure of enrichment. This gives a good idea of the biological meaning (or lack thereof) of the results. In this case, the membership of the genes is defined by the <span class="math inline">\(\kappa\)</span> value in <a href="#eq-kappa">Equation&nbsp;11</a>.</p>
<p><span id="eq-kappa"><span class="math display">\[
\begin{align}
\kappa_m &amp;= \frac{1}{1 + N_C \sigma_A^2 \tau_m^2 M^{\ast 2} \nu} \\
o &amp;\in m \forall \kappa_{o, m} &lt; 0.5
\end{align}
\tag{11}\]</span></span></p>
<p>where <span class="math inline">\(N_C\)</span> is the number of conditions and then expanding the membership from operons to genes with the <code>GxO</code> link array. In order to remove divergences and hitting max treedepth, it was found important for sampling to reparametrize the Student’s t distribution as a gamma-fixture representation (see Appendix of <span class="citation" data-cites="piironenSparsityInformationRegularization2017">Piironen and Vehtari (<a href="#ref-piironenSparsityInformationRegularization2017" role="doc-biblioref">2017</a>)</span>).</p>
<p>In table <a href="#tbl-performance">Table&nbsp;1</a>, we show the TRN enrichment for the baseline ICA without restarts and the thresholds computed by k-means, choosing the number of modulons as the one selected by the iModulon protocol (which is the one we use in our method). The performance is better for the F1 score but it is able to map less transcription factors to modulons.</p>
<div id="tbl-performance" class="anchored">
<table class="table">
<caption>Table&nbsp;1: F1-score percentiles for the baseline an our method.</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Method</th>
<th style="text-align: right;">F1-score 75%</th>
<th style="text-align: right;">F1-score 50%</th>
<th style="text-align: right;">F1-score 25%</th>
<th style="text-align: right;">Matched TFs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ICA Baseline</td>
<td style="text-align: right;">0.73</td>
<td style="text-align: right;">0.40</td>
<td style="text-align: right;">0.22</td>
<td style="text-align: right;">60</td>
</tr>
<tr class="even">
<td style="text-align: left;">This work</td>
<td style="text-align: right;">0.46</td>
<td style="text-align: right;">0.34</td>
<td style="text-align: right;">0.26</td>
<td style="text-align: right;">74</td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="about-the-global-scale" class="level2">
<h2 class="anchored" data-anchor-id="about-the-global-scale">About the global scale</h2>
<p>As implied above, there is a different <span class="math inline">\(\tau\)</span> inferred for each modulon. The global scale <span class="math inline">\(\tau_0\)</span> for each <span class="math inline">\(\tau\)</span> is calculated as:</p>
<p><span class="math display">\[
\tau = \frac{p_0} {(N_O - p_0) \sqrt {N_C}}
\]</span></p>
<p><span class="math inline">\(\sigma\)</span> is multiplied by the <span class="math inline">\(\tau_0\)</span> in the model to get the prior for <span class="math inline">\(\tau\)</span>.</p>
</section>
<section id="whitening" class="level2">
<h2 class="anchored" data-anchor-id="whitening">Whitening</h2>
<p>One of the key parts of classical ICA is the whitening of the data. Here, <em>whitening</em> refers to the transformation of the data to a space where the covariance matrix is the identity matrix. To see the effect of whitening in our implementation, the model was run on the same data with and without whitening.</p>
<p>Whitening data seems be fundamental in avoiding divergences, even when the reparametrizations of the Student’s t were applied.</p>
</section>
</section>
<section id="where-we-need-help" class="level1">
<h1>Where we need help</h1>
<p>We need to address a few statistical programming issues as we have not yet managed to implement our target model:</p>
<ul>
<li><p>Is it feasible to fit our target model and dataset with Stan, or should we try a different framework (or give up, try a simpler model etc)? What would be good potential options for simpler models or alternative frameworks?</p></li>
<li><p>What is the right way to implement the regularised horseshoe prior for this case?</p></li>
<li><p>Is there a way of making the orthogonality constraint identifiable?</p></li>
</ul>

</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-hyvarinenIndependentComponentAnalysis2000" class="csl-entry" role="listitem">
Hyvärinen, A., and E. Oja. 2000. <span>“Independent Component Analysis: Algorithms and Applications.”</span> <em>Neural Networks</em> 13 (4): 411–30. <a href="https://doi.org/10.1016/S0893-6080(00)00026-5">https://doi.org/10.1016/S0893-6080(00)00026-5</a>.
</div>
<div id="ref-jauchMonteCarloSimulation2019" class="csl-entry" role="listitem">
Jauch, Michael, Peter D. Hoff, and David B. Dunson. 2019. <span>“Monte <span>Carlo</span> Simulation on the <span>Stiefel</span> Manifold via Polar Expansion,”</span> no. arXiv:1906.07684 (June). <a href="https://doi.org/10.48550/arXiv.1906.07684">https://doi.org/10.48550/arXiv.1906.07684</a>.
</div>
<div id="ref-limFundamentalRelationshipOperon2011b" class="csl-entry" role="listitem">
Lim, Han N., Yeong Lee, and Razika Hussein. 2011. <span>“Fundamental Relationship Between Operon Organization and Gene Expression.”</span> <em>Proc Natl Acad Sci U S A</em> 108 (26): 10626–31. <a href="https://doi.org/10.1073/pnas.1105692108">https://doi.org/10.1073/pnas.1105692108</a>.
</div>
<div id="ref-piironenSparsityInformationRegularization2017" class="csl-entry" role="listitem">
Piironen, Juho, and Aki Vehtari. 2017. <span>“Sparsity Information and Regularization in the Horseshoe and Other Shrinkage Priors.”</span> <em>Electronic Journal of Statistics</em> 11 (2). <a href="https://doi.org/10.1214/17-EJS1337SI">https://doi.org/10.1214/17-EJS1337SI</a>.
</div>
<div id="ref-robertsBayesianIndependentComponent2005" class="csl-entry" role="listitem">
Roberts, Stephen, and Rizwan Choudrey. 2005. <span>“Bayesian <span>Independent Component Analysis</span> with <span>Prior Constraints</span>: <span>An Application</span> in <span>Biosignal Analysis</span>.”</span> In <em>Deterministic and <span>Statistical Methods</span> in <span>Machine Learning</span></em>, edited by Joab Winkler, Mahesan Niranjan, and Neil Lawrence, 159–79. Lecture <span>Notes</span> in <span>Computer Science</span>. <span>Berlin, Heidelberg</span>: <span>Springer</span>. <a href="https://doi.org/10.1007/11559887_10">https://doi.org/10.1007/11559887_10</a>.
</div>
<div id="ref-sastryEscherichiaColiTranscriptome2019a" class="csl-entry" role="listitem">
Sastry, Anand V., Ye Gao, Richard Szubin, Ying Hefner, Sibei Xu, Donghyuk Kim, Kumari Sonal Choudhary, Laurence Yang, Zachary A. King, and Bernhard O. Palsson. 2019. <span>“The <span>Escherichia</span> Coli Transcriptome Mostly Consists of Independently Regulated Modules.”</span> <em>Nat Commun</em> 10 (1): 5536. <a href="https://doi.org/10.1038/s41467-019-13483-w">https://doi.org/10.1038/s41467-019-13483-w</a>.
</div>
<div id="ref-tanIndependentComponentAnalysis2020" class="csl-entry" role="listitem">
Tan, Justin, Anand V. Sastry, Karoline S. Fremming, Sara P. Bjørn, Alexandra Hoffmeyer, Sangwoo Seo, Bjørn G. Voldborg, and Bernhard O. Palsson. 2020. <span>“Independent Component Analysis of <span>E</span>. Coli’s Transcriptome Reveals the Cellular Processes That Respond to Heterologous Gene Expression.”</span> <em>Metabolic Engineering</em> 61 (September): 360–68. <a href="https://doi.org/10.1016/j.ymben.2020.07.002">https://doi.org/10.1016/j.ymben.2020.07.002</a>.
</div>
<div id="ref-zhaoMisuseRPKMTPM2020" class="csl-entry" role="listitem">
Zhao, Shanrong, Zhan Ye, and Robert Stanton. 2020. <span>“Misuse of <span>RPKM</span> or <span>TPM</span> Normalization When Comparing Across Samples and Sequencing Protocols.”</span> <em>RNA</em> 26 (8): 903–9. <a href="https://doi.org/10.1261/rna.074922.120">https://doi.org/10.1261/rna.074922.120</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>